/**
 *  vars
 *  (c) VARIANTE (http://variante.io)
 *
 *  This software is released under the MIT License:
 *  http://www.opensource.org/licenses/mit-license.php
 */

/**
 * Clearfix hack for floated elements.
 */
@mixin clearfix
{
    *zoom: 1;

    &:before
    {
        content: '';
        display: table;
    }

    &:after
    {
        content: '';
        display: table;
        clear: both;
    }
}

/**
 * Transforms containing selector into a container that can freely align
 * child inline-blocks with no fixed width/height requirements. Beware of whitespace
 * between inline elements.
 *
 * @param   {String} $alignH    Horizontal alignment of child elements (i.e. left, center, right).
 * @param   {String} $alignV    Vertical alignment of child elements (i.e. top, center, bototm).
 * @param   {String} $inline    Specifies if this block is an inline block.
 */
@mixin fluid-block($alignH:center, $alignV:center, $inline:false)
{
    @if      $alignH == 'left'                          { text-align: left;   }
    @else if $alignH == 'center' or $alignH == 'middle' { text-align: center; }
    @else if $alignH == 'right'                         { text-align: right;  }

    @if $alignV == 'top'                                { & > * { vertical-align: top;    } }
    @else if $alignV == 'center' or $alignV == 'middle' { & > * { vertical-align: middle; } }
    @else if $alignV == 'bottom'                        { & > * { vertical-align: bottom; } }

    @if   $inline == true { display: inline-block; }
    @else                 { display: block;        }

    & > *
    {
        display: inline-block;
    }

    &:before
    {
        height: 100%;
        vertical-align: middle;
        content: '';
        display: inline-block;
    }
}

/**
 * Transforms containing selector into a flexbox which auto aligns child
 * elements according to the specified params.
 *
 * @param   {String}  $alignH       Horizontal alignment of child elements (i.e. left, center, right).
 * @param   {String}  $alignV       Vertical alignment of child elements (i.e. top, middle, bottom).
 * @param   {Boolean} $direction    Determines the main axis (i.e. row, row-reverse, column, column-reverse).
 * @param   {Boolean} $wrap         Determines if wrapping is enabled.
 * @param   {String}  $inline       Specifies if this flexbox is inline.
 */
@mixin flex-block($alignH:center, $alignV:center, $direction:row, $wrap:false, $inline:false)
{
    line-height: normal;
    white-space: normal;

    @if   $wrap == true { flex-wrap: wrap;   }
    @else               { flex-wrap: nowrap; }

    @if $direction == 'row'
    {
        flex-direction: row;

        @if      $alignH == 'left'                          { justify-content: flex-start; }
        @else if $alignH == 'center' or $alignH == 'middle' { justify-content: center;     }
        @else if $alignH == 'right'                         { justify-content: flex-end;   }

        @if      $alignV == 'top'                           { align-items: flex-start; }
        @else if $alignV == 'center' or $alignV == 'middle' { align-items: center;     }
        @else if $alignV == 'bottom'                        { align-items: flex-end;   }
    }
    @else if $direction == 'row-reverse'
    {
        flex-direction: row-reverse;

        @if      $alignH == 'left'                          { justify-content: flex-end;   }
        @else if $alignH == 'center' or $alignH == 'middle' { justify-content: center;     }
        @else if $alignH == 'right'                         { justify-content: flex-start; }

        @if      $alignV == 'top'                           { align-items: flex-start; }
        @else if $alignV == 'center' or $alignV == 'middle' { align-items: center;     }
        @else if $alignV == 'bottom'                        { align-items: flex-end;   }
    }
    @else if $direction == 'column'
    {
        flex-direction: column;

        @if      $alignV == 'top'                            { justify-content: flex-start; }
        @else if $alignV == 'center' or $alignV == 'middle'  { justify-content: center;     }
        @else if $alignV == 'bottom'                         { justify-content: flex-end;   }

        @if      $alignH == 'left'                          { align-items: flex-start; }
        @else if $alignH == 'center' or $alignH == 'middle' { align-items: center;     }
        @else if $alignH == 'right'                         { align-items: flex-end;   }
    }
    @else if $direction == 'column-reverse'
    {
        flex-direction: column-reverse;

        @if      $alignV == 'top'                            { justify-content: flex-end;   }
        @else if $alignV == 'center' or $alignV == 'middle'  { justify-content: center;     }
        @else if $alignV == 'bottom'                         { justify-content: flex-start; }

        @if      $alignH == 'left'                          { align-items: flex-start; }
        @else if $alignH == 'center' or $alignH == 'middle' { align-items: center;     }
        @else if $alignH == 'right'                         { align-items: flex-end;   }
    }

    @if   $inline == true { display: inline-flex; }
    @else                 { display: flex;        }
}

/**
 * Aligns containing selector to specified x/y directions in absolute position.
 *
 * @param  {List} $alignH     Horizontal alignment (left|center|right, left|right offset, right offset).
 * @param  {List} $alignV     Vertical alignment (top|center|middle|bottom, top|bottom offset, bottom offset).
 */
@mixin abs-align($alignH:null, $alignV:null)
{
    display: block;
    position: absolute;

    @if $alignH != null and length($alignH) > 0
    {
        $align: nth($alignH, 1);
        $offset1: null;
        $offset2: null;

        @if length($alignH) > 1 { $offset1: nth($alignH, 2); }
        @if length($alignH) > 2 { $offset2: nth($alignH, 3); }

        @if $align == 'left'
        {
            @if $offset1 == null { left: 0px; } @else { left: $offset1; }
        }
        @else if $align == 'center' or $align == 'middle'
        {
            margin-left: auto;
            margin-right: auto;
            @if $offset1 == null { left: 0px;  } @else { left: $offset1;  }
            @if $offset2 == null { right: 0px; } @else { right: $offset2; }
        }
        @else if $align == 'right'
        {
            @if $offset1 == null { right: 0px; } @else { right: $offset1; }
        }
    }

    @if $alignV != null and length($alignV) > 0
    {
        $align: nth($alignV, 1);
        $offset1: null;
        $offset2: null;

        @if length($alignV) > 1 { $offset1: nth($alignV, 2); }
        @if length($alignV) > 2 { $offset2: nth($alignV, 3); }

        @if $align == 'top'
        {
            @if $offset1 == null { top: 0px; } @else { top: $offset1; }
        }
        @else if $align == 'center' or $align == 'middle'
        {
            margin-top: auto;
            margin-bottom: auto;
            @if $offset1 == null { top: 0px;    } @else { top: $offset1;    }
            @if $offset2 == null { bottom: 0px; } @else { bottom: $offset2; }
        }
        @else if $align == 'bottom'
        {
            @if $offset1 == null { bottom: 0px; } @else { bottom: $offset1; }
        }
    }
}

/**
 * Aligns containing selector to specified x/y directions in fixed position.
 *
 * @param  {List} $alignH     Horizontal alignment (left|center|right, left|right offset, right offset).
 * @param  {List} $alignV     Vertical alignment (top|center|middle|bottom, top|bottom offset, bottom offset).
 */
@mixin fixed-align($alignH:null, $alignV:null)
{
    display: block;
    position: fixed;

    @if $alignH != null and length($alignH) > 0
    {
        $align: nth($alignH, 1);
        $offset1: null;
        $offset2: null;

        @if length($alignH) > 1 { $offset1: nth($alignH, 2); }
        @if length($alignH) > 2 { $offset2: nth($alignH, 3); }

        @if $align == 'left'
        {
            @if $offset1 == null { left: 0px; } @else { left: $offset1; }
        }
        @else if $align == 'center' or $align == 'middle'
        {
            margin-left: auto;
            margin-right: auto;
            @if $offset1 == null { left: 0px;  } @else { left: $offset1;  }
            @if $offset2 == null { right: 0px; } @else { right: $offset2; }
        }
        @else if $align == 'right'
        {
            @if $offset1 == null { right: 0px; } @else { right: $offset1; }
        }
    }

    @if $alignV != null and length($alignV) > 0
    {
        $align: nth($alignV, 1);
        $offset1: null;
        $offset2: null;

        @if length($alignV) > 1 { $offset1: nth($alignV, 2); }
        @if length($alignV) > 2 { $offset2: nth($alignV, 3); }

        @if $align == 'top'
        {
            @if $offset1 == null { top: 0px; } @else { top: $offset1; }
        }
        @else if $align == 'center' or $align == 'middle'
        {
            margin-top: auto;
            margin-bottom: auto;
            @if $offset1 == null { top: 0px;    } @else { top: $offset1;    }
            @if $offset2 == null { bottom: 0px; } @else { bottom: $offset2; }
        }
        @else if $align == 'bottom'
        {
            @if $offset1 == null { bottom: 0px; } @else { bottom: $offset1; }
        }
    }
}

/**
 * Aligns containing inline-block to specified x/y directions in relative
 * position.
 *
 * @param  {String} $alignH     Horizontal alignment (i.e. left, center, right).
 * @param  {String} $alignV     Vertical alignment (i.e. top, middle, bottom).
 */
@mixin inline-align($alignH:null, $alignV:null)
{
    display: inline-block;
    position: relative;

    // Horizontal alignment cannot be altered at the child level. Tweak
    // the parent's text-align rule instead.

    @if      $alignV == 'top'                           { vertical-align: top;    }
    @else if $alignV == 'center' or $alignV == 'middle' { vertical-align: middle; }
    @else if $alignV == 'bottom'                        { vertical-align: bottom; }
}

/**
 * Transforms target selector into a container for
 * parallax elements.
 *
 * @param  {Number} $perspective    Tweak this value to adjust perspective.
 * @see parallax-element
 */
@mixin parallax-block($perspective:1)
{
    height: 100vh;
    overflow-x: hidden;
    overflow-y: scroll;
    perspective: #{$perspective + px};
}

/**
 * Transforms target selector into a parallax element. The
 * target selector must be a child of a parallax-block.
 *
 * @param  {String} $type   Layer type, either 'group' or 'layer'.
 * @param  {Number} $z      Position in the z-axis.
 * @see parallax-block
 */
@mixin parallax-element($type:layer, $z:0)
{
    @if $type == 'group'
    {
        height: 100vh;
        position: relative;
        transform-style: preserve-3d;
    }
    @else if $type == 'layer'
    {
        transform: translateZ(#{$z + px});
    }
}

/**
 * Sets the diameter of the target selector.
 *
 * @param  {Number}  $diameter
 * @param  {Boolean} $oval
 */
@mixin diameter($diameter, $oval:false)
{
    width: $diameter;
    height: $diameter;

    @if $oval == true
    {
        border-radius: $diameter / 2;
        overflow: hidden;
    }
}

/**
 * Fits dimension to parent container.
 *
 * @param  {Boolean} $w     Specifies whether to fit the width.
 * @param  {Boolean} $h     Specifies whether to fit the height.
 */
@mixin auto-fit($w:true, $h:true)
{
    @if $w == true
    {
        width: 100%;
    }

    @if $h == true
    {
        height: 100%;
    }
}

/**
 * Sets the background-size and background-position of a target element
 * which is using an image map to the corresponding item in the map.
 *
 * @param  {Number} $row-index 0-based index of the row of the target item.
 * @param  {Number} $col-index 0-based index of the column of the target item.
 * @param  {Number} $num-rows  Total number of rows in the image map.
 * @param  {Number} $num-cols  Total number of columns in the image map.
 */
@mixin image-map-item($row-index, $col-index, $num-rows, $num-cols)
{
    background-size: #{$num-cols * 100}% #{$num-rows * 100}%;
    background-position: #{((100 / ($num-cols - 1)) * $col-index)}% #{((100 / ($num-rows - 1)) * $row-index)}%;
}
